<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/client/src/components/ContentPanel.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/client/src/components/ContentPanel.tsx" />
              <option name="originalContent" value="import {useEffect, useRef, useState} from &quot;react&quot;;&#10;import {useNoteContext} from &quot;@/context/NoteContext&quot;;&#10;import {NoteService} from &quot;@/services/NoteService&quot;;&#10;import type {Block, Note} from &quot;@/types/Note.ts&quot;;&#10;import {TextBlock} from &quot;@/components/blocks/block_types/TextBlock.tsx&quot;;&#10;import {&#10;    DndContext,&#10;    closestCenter,&#10;    KeyboardSensor,&#10;    PointerSensor,&#10;    useSensor,&#10;    useSensors,&#10;    type DragEndEvent, DragOverlay, type DragStartEvent,&#10;} from '@dnd-kit/core';&#10;import {&#10;    arrayMove,&#10;    SortableContext,&#10;    sortableKeyboardCoordinates,&#10;    verticalListSortingStrategy,&#10;} from '@dnd-kit/sortable';&#10;import {SortableBlock} from &quot;@/components/blocks/SortableBlock.tsx&quot;;&#10;import {CanvasBlock} from &quot;@/components/blocks/block_types/CanvasBlock.tsx&quot;;&#10;import {ChevronDownIcon, DocumentTextIcon, PhotoIcon, RectangleGroupIcon} from '@heroicons/react/24/outline';&#10;&#10;async function createBlock(type: &quot;text&quot; | &quot;canvas&quot; | &quot;image&quot;, noteId: string, index: number): Promise&lt;Block&gt; {&#10;    const blockRequest = {&#10;        type: type,&#10;        index,&#10;        content: &quot;&quot;&#10;    };&#10;&#10;    return await NoteService.createBlock(noteId, blockRequest);&#10;}&#10;&#10;export function MainContentPanel() {&#10;    const {selectedNoteId, noteTitle} = useNoteContext();&#10;    const [note, setNote] = useState&lt;Note | null&gt;(null);&#10;    const [loading, setLoading] = useState(false);&#10;    const [activeBlock, setActiveBlock] = useState&lt;Block | null&gt;(null);&#10;    const [showAddMenu, setShowAddMenu] = useState(false);&#10;    const dropdownRef = useRef&lt;HTMLDivElement&gt;(null);&#10;&#10;    const sensors = useSensors(&#10;        useSensor(PointerSensor),&#10;        useSensor(KeyboardSensor, {&#10;            coordinateGetter: sortableKeyboardCoordinates,&#10;        })&#10;    );&#10;&#10;    useEffect(() =&gt; {&#10;        setLoading(true);&#10;        if (!selectedNoteId) {&#10;            setNote(null);&#10;            return;&#10;        }&#10;&#10;        const fetchNote = async () =&gt; {&#10;            try {&#10;                const fetched = await NoteService.getNote(selectedNoteId);&#10;                setNote(fetched);&#10;            } catch (err) {&#10;                console.error(&quot;Failed to load note:&quot;, err);&#10;                setNote(null);&#10;            } finally {&#10;                setLoading(false);&#10;            }&#10;        };&#10;&#10;        fetchNote();&#10;    }, [selectedNoteId]);&#10;&#10;    const getDropdownPosition = (): 'up' | 'down' =&gt; {&#10;        if (!dropdownRef.current) return 'down';&#10;&#10;        const rect = dropdownRef.current.getBoundingClientRect();&#10;        const viewportHeight = window.innerHeight;&#10;        const spaceBelow = viewportHeight - rect.bottom;&#10;        const dropdownHeight = 200; // Approximate height of dropdown&#10;&#10;        return spaceBelow &gt;= dropdownHeight ? 'down' : 'up';&#10;    };&#10;&#10;    const handleToggleMenu = () =&gt; {&#10;        setShowAddMenu(!showAddMenu);&#10;    };&#10;&#10;    const handleAddBlock = async (type: &quot;text&quot; | &quot;canvas&quot; | &quot;image&quot;) =&gt; {&#10;        if (!note || !selectedNoteId) return;&#10;&#10;        try {&#10;            await createBlock(type, selectedNoteId, note.blocks.length);&#10;            const updatedNote = await NoteService.getNote(selectedNoteId);&#10;            setNote(updatedNote);&#10;            setShowAddMenu(false);&#10;        } catch (err) {&#10;            console.error(`Failed to add ${type} block:`, err);&#10;        }&#10;    };&#10;&#10;    const handleDeleteBlock = async (blockId: string) =&gt; {&#10;        if (!selectedNoteId) return;&#10;&#10;        try {&#10;            await NoteService.deleteBlock(selectedNoteId, blockId);&#10;            const updatedNote = await NoteService.getNote(selectedNoteId);&#10;            setNote(updatedNote);&#10;        } catch (error) {&#10;            console.error('Error deleting block:', error);&#10;        }&#10;    };&#10;&#10;    const handleDragStart = (event: DragStartEvent) =&gt; {&#10;        const {active} = event;&#10;        const block = note?.blocks.find(b =&gt; b.id === active.id) || null;&#10;        setActiveBlock(block);&#10;    };&#10;&#10;    const handleDragEnd = async (event: DragEndEvent) =&gt; {&#10;        const {active, over} = event;&#10;        setActiveBlock(null);&#10;&#10;        if (!over || !note || !selectedNoteId) return;&#10;&#10;        if (active.id !== over.id) {&#10;            const sortedBlocks = [...note.blocks].sort((a, b) =&gt; a.index - b.index);&#10;&#10;            const oldIndex = sortedBlocks.findIndex(block =&gt; block.id === active.id);&#10;            const newIndex = sortedBlocks.findIndex(block =&gt; block.id === over.id);&#10;&#10;            const reorderedBlocks = arrayMove(sortedBlocks, oldIndex, newIndex);&#10;&#10;            const blocksWithNewIndices = reorderedBlocks.map((block, index) =&gt; ({&#10;                ...block,&#10;                index: index&#10;            }));&#10;&#10;            setNote(prev =&gt; prev ? {&#10;                ...prev,&#10;                blocks: blocksWithNewIndices&#10;            } : null);&#10;&#10;            try {&#10;                await NoteService.updateNote({&#10;                    id: selectedNoteId,&#10;                    title: note.title,&#10;                    folder_id: note.folder_id,&#10;                    blocks: blocksWithNewIndices&#10;                });&#10;            } catch (err) {&#10;                console.error(&quot;Failed to reorder blocks:&quot;, err);&#10;                const updatedNote = await NoteService.getNote(selectedNoteId);&#10;                setNote(updatedNote);&#10;            }&#10;        }&#10;    };&#10;&#10;    if (!selectedNoteId) {&#10;        return &lt;div className=&quot;p-6 text-gray-500&quot;&gt;No note selected&lt;/div&gt;;&#10;    }&#10;&#10;    if (loading) {&#10;        return &lt;div className=&quot;p-6 text-gray-500&quot;&gt;Loading note...&lt;/div&gt;;&#10;    }&#10;&#10;    const sortedBlocks = note?.blocks ? [...note.blocks].sort((a, b) =&gt; a.index - b.index) : [];&#10;&#10;    return (&#10;        note &amp;&amp; (&#10;            &lt;div className=&quot;p-6 space-y-4&quot;&gt;&#10;                &lt;div className=&quot;flex justify-center&quot;&gt;&#10;                    &lt;h1 className=&quot;text-xl font-semibold text-gray-800&quot;&gt;{noteTitle}&lt;/h1&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;DndContext&#10;                    sensors={sensors}&#10;                    collisionDetection={closestCenter}&#10;                    onDragEnd={handleDragEnd}&#10;                    onDragStart={handleDragStart}&#10;                &gt;&#10;                    &lt;SortableContext&#10;                        items={sortedBlocks.map(block =&gt; block.id)}&#10;                        strategy={verticalListSortingStrategy}&#10;                    &gt;&#10;                        &lt;div className=&quot;space-y-2 flex flex-col w-full&quot;&gt;&#10;                            {sortedBlocks.map((block: Block) =&gt; {&#10;                                switch (block.type) {&#10;                                    case &quot;text&quot;:&#10;                                        return (&#10;                                            &lt;div key={block.id} className=&quot;flex justify-center&quot;&gt;&#10;                                                &lt;SortableBlock blockId={block.id} onDelete={handleDeleteBlock}&gt;&#10;                                                    &lt;TextBlock key={block.id} block={block}/&gt;&#10;                                                &lt;/SortableBlock&gt;&#10;                                            &lt;/div&gt;&#10;                                        );&#10;                                    case &quot;image&quot;:&#10;                                        return &lt;p key={block.id}&gt;image&lt;/p&gt;;&#10;                                    case &quot;canvas&quot;:&#10;                                        return (&#10;                                            &lt;div key={block.id} className=&quot;flex justify-center&quot;&gt;&#10;                                                &lt;SortableBlock blockId={block.id} onDelete={handleDeleteBlock}&gt;&#10;                                                    &lt;CanvasBlock key={block.id} block={block}/&gt;&#10;                                                &lt;/SortableBlock&gt;&#10;                                            &lt;/div&gt;&#10;                                        );&#10;                                    default:&#10;                                        return (&#10;                                            &lt;div key={block.id} className=&quot;text-red-600&quot;&gt;&#10;                                                Unknown block type: {block.type}&#10;                                            &lt;/div&gt;&#10;                                        );&#10;                                }&#10;                            })}&#10;                        &lt;/div&gt;&#10;                    &lt;/SortableContext&gt;&#10;&#10;                    &lt;DragOverlay&gt;&#10;                        {activeBlock?.type === &quot;text&quot; &amp;&amp; &lt;TextBlock block={activeBlock}/&gt;}&#10;                        {activeBlock?.type === &quot;canvas&quot; &amp;&amp; &lt;CanvasBlock block={activeBlock}/&gt;}&#10;                    &lt;/DragOverlay&gt;&#10;                &lt;/DndContext&gt;&#10;&#10;                &lt;div className=&quot;flex justify-center mt-8&quot;&gt;&#10;                    &lt;div className=&quot;relative&quot; ref={dropdownRef}&gt;&#10;                        &lt;button&#10;                            className=&quot;inline-flex items-center px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg shadow-sm transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2&quot;&#10;                            onClick={handleToggleMenu}&#10;                        &gt;&#10;                            &lt;span&gt;Add Block&lt;/span&gt;&#10;                            &lt;ChevronDownIcon className=&quot;ml-2 h-4 w-4&quot;/&gt;&#10;                        &lt;/button&gt;&#10;&#10;                        {showAddMenu &amp;&amp; (&#10;                            &lt;&gt;&#10;                                &lt;div&#10;                                    className={`absolute w-48 bg-white rounded-lg shadow-lg border border-gray-200 z-10 ${&#10;                                        getDropdownPosition() === 'up'&#10;                                            ? 'bottom-full mb-2'&#10;                                            : 'top-full mt-2'&#10;                                    }`}&gt;&#10;                                    &lt;div className=&quot;py-1&quot;&gt;&#10;                                        &lt;button&#10;                                            className=&quot;flex items-center w-full px-4 py-3 text-left text-gray-700 hover:bg-gray-50 transition-colors duration-150&quot;&#10;                                            onClick={() =&gt; handleAddBlock(&quot;text&quot;)}&#10;                                        &gt;&#10;                                            &lt;DocumentTextIcon className=&quot;h-5 w-5 mr-3 text-gray-500&quot;/&gt;&#10;                                            &lt;div&gt;&#10;                                                &lt;div className=&quot;font-medium&quot;&gt;Text Block&lt;/div&gt;&#10;                                                &lt;div className=&quot;text-sm text-gray-500&quot;&gt;Add formatted text content&lt;/div&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/button&gt;&#10;&#10;                                        &lt;button&#10;                                            className=&quot;flex items-center w-full px-4 py-3 text-left text-gray-700 hover:bg-gray-50 transition-colors duration-150&quot;&#10;                                            onClick={() =&gt; handleAddBlock(&quot;canvas&quot;)}&#10;                                        &gt;&#10;                                            &lt;RectangleGroupIcon className=&quot;h-5 w-5 mr-3 text-gray-500&quot;/&gt;&#10;                                            &lt;div&gt;&#10;                                                &lt;div className=&quot;font-medium&quot;&gt;Canvas Block&lt;/div&gt;&#10;                                                &lt;div className=&quot;text-sm text-gray-500&quot;&gt;Add drawing or diagram&lt;/div&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/button&gt;&#10;&#10;                                        &lt;button&#10;                                            className=&quot;flex items-center w-full px-4 py-3 text-left text-gray-700 hover:bg-gray-50 transition-colors duration-150&quot;&#10;                                            onClick={() =&gt; handleAddBlock(&quot;image&quot;)}&#10;                                        &gt;&#10;                                            &lt;PhotoIcon className=&quot;h-5 w-5 mr-3 text-gray-500&quot;/&gt;&#10;                                            &lt;div&gt;&#10;                                                &lt;div className=&quot;font-medium&quot;&gt;Image Block&lt;/div&gt;&#10;                                                &lt;div className=&quot;text-sm text-gray-500&quot;&gt;Upload or embed images&lt;/div&gt;&#10;                                            &lt;/div&gt;&#10;                                        &lt;/button&gt;&#10;                                    &lt;/div&gt;&#10;                                &lt;/div&gt;&#10;&#10;                                &lt;div&#10;                                    className=&quot;fixed inset-0 z-0&quot;&#10;                                    onClick={() =&gt; setShowAddMenu(false)}&#10;                                /&gt;&#10;                            &lt;/&gt;&#10;                        )}&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        )&#10;    );&#10;}" />
              <option name="updatedContent" value="import {useEffect, useState, Fragment} from &quot;react&quot;;&#10;import {useNoteContext} from &quot;@/context/NoteContext&quot;;&#10;import {NoteService} from &quot;@/services/NoteService&quot;;&#10;import type {Block, Note} from &quot;@/types/Note.ts&quot;;&#10;import {TextBlock} from &quot;@/components/blocks/block_types/TextBlock.tsx&quot;;&#10;import {&#10;    DndContext,&#10;    closestCenter,&#10;    KeyboardSensor,&#10;    PointerSensor,&#10;    useSensor,&#10;    useSensors,&#10;    type DragEndEvent, DragOverlay, type DragStartEvent,&#10;} from '@dnd-kit/core';&#10;import {&#10;    arrayMove,&#10;    SortableContext,&#10;    sortableKeyboardCoordinates,&#10;    verticalListSortingStrategy,&#10;} from '@dnd-kit/sortable';&#10;import {SortableBlock} from &quot;@/components/blocks/SortableBlock.tsx&quot;;&#10;import {CanvasBlock} from &quot;@/components/blocks/block_types/CanvasBlock.tsx&quot;;&#10;import {DocumentTextIcon, PhotoIcon, RectangleGroupIcon} from '@heroicons/react/24/outline';&#10;&#10;async function createBlock(type: &quot;text&quot; | &quot;canvas&quot; | &quot;image&quot;, noteId: string, index: number): Promise&lt;Block&gt; {&#10;    const blockRequest = {&#10;        type: type,&#10;        index,&#10;        content: &quot;&quot;&#10;    };&#10;&#10;    return await NoteService.createBlock(noteId, blockRequest);&#10;}&#10;&#10;// New inline divider component for inserting blocks at specific positions&#10;function InsertionDivider({ onAdd }: { onAdd: (type: &quot;text&quot; | &quot;canvas&quot; | &quot;image&quot;) =&gt; void }) {&#10;    return (&#10;        &lt;div className=&quot;relative group flex items-center my-2 h-10&quot;&gt;&#10;            &lt;div className=&quot;w-full h-px bg-transparent group-hover:bg-gray-200 transition-colors duration-200&quot; /&gt;&#10;            &lt;div className=&quot;absolute left-1/2 -translate-x-1/2&quot;&gt;&#10;                &lt;div className=&quot;opacity-0 group-hover:opacity-100 transition-opacity duration-200&quot;&gt;&#10;                    &lt;div className=&quot;flex gap-2&quot;&gt;&#10;                        &lt;button&#10;                            onClick={() =&gt; onAdd(&quot;text&quot;)}&#10;                            className=&quot;px-3 py-1.5 border border-gray-300 rounded-md bg-white hover:bg-gray-50 text-xs font-medium text-gray-700 shadow-sm inline-flex items-center gap-1&quot;&#10;                            title=&quot;Add text block&quot;&#10;                        &gt;&#10;                            &lt;DocumentTextIcon className=&quot;h-4 w-4 text-gray-500&quot; /&gt;&#10;                            Text&#10;                        &lt;/button&gt;&#10;                        &lt;button&#10;                            onClick={() =&gt; onAdd(&quot;canvas&quot;)}&#10;                            className=&quot;px-3 py-1.5 border border-gray-300 rounded-md bg-white hover:bg-gray-50 text-xs font-medium text-gray-700 shadow-sm inline-flex items-center gap-1&quot;&#10;                            title=&quot;Add canvas block&quot;&#10;                        &gt;&#10;                            &lt;RectangleGroupIcon className=&quot;h-4 w-4 text-gray-500&quot; /&gt;&#10;                            Canvas&#10;                        &lt;/button&gt;&#10;                        &lt;button&#10;                            onClick={() =&gt; onAdd(&quot;image&quot;)}&#10;                            className=&quot;px-3 py-1.5 border border-gray-300 rounded-md bg-white hover:bg-gray-50 text-xs font-medium text-gray-700 shadow-sm inline-flex items-center gap-1&quot;&#10;                            title=&quot;Add image block&quot;&#10;                        &gt;&#10;                            &lt;PhotoIcon className=&quot;h-4 w-4 text-gray-500&quot; /&gt;&#10;                            Image&#10;                        &lt;/button&gt;&#10;                    &lt;/div&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export function MainContentPanel() {&#10;    const {selectedNoteId, noteTitle} = useNoteContext();&#10;    const [note, setNote] = useState&lt;Note | null&gt;(null);&#10;    const [loading, setLoading] = useState(false);&#10;    const [activeBlock, setActiveBlock] = useState&lt;Block | null&gt;(null);&#10;&#10;    const sensors = useSensors(&#10;        useSensor(PointerSensor),&#10;        useSensor(KeyboardSensor, {&#10;            coordinateGetter: sortableKeyboardCoordinates,&#10;        })&#10;    );&#10;&#10;    useEffect(() =&gt; {&#10;        setLoading(true);&#10;        if (!selectedNoteId) {&#10;            setNote(null);&#10;            return;&#10;        }&#10;&#10;        const fetchNote = async () =&gt; {&#10;            try {&#10;                const fetched = await NoteService.getNote(selectedNoteId);&#10;                setNote(fetched);&#10;            } catch (err) {&#10;                console.error(&quot;Failed to load note:&quot;, err);&#10;                setNote(null);&#10;            } finally {&#10;                setLoading(false);&#10;            }&#10;        };&#10;&#10;        fetchNote();&#10;    }, [selectedNoteId]);&#10;&#10;    // Replace append-only add with position-aware add&#10;    const handleAddBlockAt = async (type: &quot;text&quot; | &quot;canvas&quot; | &quot;image&quot;, index: number) =&gt; {&#10;        if (!note || !selectedNoteId) return;&#10;        try {&#10;            // Create the block at the requested index on the server&#10;            const created = await createBlock(type, selectedNoteId, index);&#10;&#10;            // Refetch to get the latest blocks (including the new one)&#10;            const fetched = await NoteService.getNote(selectedNoteId);&#10;&#10;            // Sort by existing indices&#10;            const blocksSorted = [...fetched.blocks].sort((a, b) =&gt; a.index - b.index);&#10;&#10;            // Remove the newly created block from its current position&#10;            const newIdxCurrent = blocksSorted.findIndex(b =&gt; b.id === created.id);&#10;            let withoutNew = blocksSorted;&#10;            if (newIdxCurrent !== -1) {&#10;                withoutNew = [&#10;                    ...blocksSorted.slice(0, newIdxCurrent),&#10;                    ...blocksSorted.slice(newIdxCurrent + 1)&#10;                ];&#10;            }&#10;&#10;            // Clamp target index and insert the new block there&#10;            const targetIndex = Math.max(0, Math.min(index, withoutNew.length));&#10;            const reordered = [&#10;                ...withoutNew.slice(0, targetIndex),&#10;                blocksSorted[newIdxCurrent !== -1 ? newIdxCurrent : blocksSorted.length - 1],&#10;                ...withoutNew.slice(targetIndex)&#10;            ];&#10;&#10;            // Reindex sequentially&#10;            const blocksWithNewIndices: Block[] = reordered.map((b, i) =&gt; ({ ...b, index: i }));&#10;&#10;            // Persist new indices&#10;            await NoteService.updateNote({&#10;                id: selectedNoteId,&#10;                title: fetched.title,&#10;                folder_id: fetched.folder_id,&#10;                blocks: blocksWithNewIndices&#10;            });&#10;&#10;            // Update local state&#10;            setNote({ ...fetched, blocks: blocksWithNewIndices });&#10;        } catch (err) {&#10;            console.error(`Failed to add ${type} block at index ${index}:`, err);&#10;        }&#10;    };&#10;&#10;    const handleDeleteBlock = async (blockId: string) =&gt; {&#10;        if (!selectedNoteId) return;&#10;&#10;        try {&#10;            await NoteService.deleteBlock(selectedNoteId, blockId);&#10;            const updatedNote = await NoteService.getNote(selectedNoteId);&#10;            setNote(updatedNote);&#10;        } catch (error) {&#10;            console.error('Error deleting block:', error);&#10;        }&#10;    };&#10;&#10;    const handleDragStart = (event: DragStartEvent) =&gt; {&#10;        const {active} = event;&#10;        const block = note?.blocks.find(b =&gt; b.id === active.id) || null;&#10;        setActiveBlock(block);&#10;    };&#10;&#10;    const handleDragEnd = async (event: DragEndEvent) =&gt; {&#10;        const {active, over} = event;&#10;        setActiveBlock(null);&#10;&#10;        if (!over || !note || !selectedNoteId) return;&#10;&#10;        if (active.id !== over.id) {&#10;            const sortedBlocks = [...note.blocks].sort((a, b) =&gt; a.index - b.index);&#10;&#10;            const oldIndex = sortedBlocks.findIndex(block =&gt; block.id === active.id);&#10;            const newIndex = sortedBlocks.findIndex(block =&gt; block.id === over.id);&#10;&#10;            const reorderedBlocks = arrayMove(sortedBlocks, oldIndex, newIndex);&#10;&#10;            const blocksWithNewIndices = reorderedBlocks.map((block, index) =&gt; ({&#10;                ...block,&#10;                index: index&#10;            }));&#10;&#10;            setNote(prev =&gt; prev ? {&#10;                ...prev,&#10;                blocks: blocksWithNewIndices&#10;            } : null);&#10;&#10;            try {&#10;                await NoteService.updateNote({&#10;                    id: selectedNoteId,&#10;                    title: note.title,&#10;                    folder_id: note.folder_id,&#10;                    blocks: blocksWithNewIndices&#10;                });&#10;            } catch (err) {&#10;                console.error(&quot;Failed to reorder blocks:&quot;, err);&#10;                const updatedNote = await NoteService.getNote(selectedNoteId);&#10;                setNote(updatedNote);&#10;            }&#10;        }&#10;    };&#10;&#10;    if (!selectedNoteId) {&#10;        return &lt;div className=&quot;p-6 text-gray-500&quot;&gt;No note selected&lt;/div&gt;;&#10;    }&#10;&#10;    if (loading) {&#10;        return &lt;div className=&quot;p-6 text-gray-500&quot;&gt;Loading note...&lt;/div&gt;;&#10;    }&#10;&#10;    const sortedBlocks = note?.blocks ? [...note.blocks].sort((a, b) =&gt; a.index - b.index) : [];&#10;&#10;    return (&#10;        note &amp;&amp; (&#10;            &lt;div className=&quot;p-6 space-y-4&quot;&gt;&#10;                &lt;div className=&quot;flex justify-center&quot;&gt;&#10;                    &lt;h1 className=&quot;text-xl font-semibold text-gray-800&quot;&gt;{noteTitle}&lt;/h1&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;DndContext&#10;                    sensors={sensors}&#10;                    collisionDetection={closestCenter}&#10;                    onDragEnd={handleDragEnd}&#10;                    onDragStart={handleDragStart}&#10;                &gt;&#10;                    &lt;SortableContext&#10;                        items={sortedBlocks.map(block =&gt; block.id)}&#10;                        strategy={verticalListSortingStrategy}&#10;                    &gt;&#10;                        &lt;div className=&quot;space-y-2 flex flex-col w-full&quot;&gt;&#10;                            {sortedBlocks.length === 0 &amp;&amp; (&#10;                                &lt;InsertionDivider onAdd={(type) =&gt; handleAddBlockAt(type, 0)} /&gt;&#10;                            )}&#10;                            {sortedBlocks.map((block: Block, i: number) =&gt; (&#10;                                &lt;Fragment key={block.id}&gt;&#10;                                    {(() =&gt; {&#10;                                        switch (block.type) {&#10;                                            case &quot;text&quot;:&#10;                                                return (&#10;                                                    &lt;div className=&quot;flex justify-center&quot;&gt;&#10;                                                        &lt;SortableBlock blockId={block.id} onDelete={handleDeleteBlock}&gt;&#10;                                                            &lt;TextBlock block={block} /&gt;&#10;                                                        &lt;/SortableBlock&gt;&#10;                                                    &lt;/div&gt;&#10;                                                );&#10;                                            case &quot;image&quot;:&#10;                                                return &lt;p&gt;image&lt;/p&gt;;&#10;                                            case &quot;canvas&quot;:&#10;                                                return (&#10;                                                    &lt;div className=&quot;flex justify-center&quot;&gt;&#10;                                                        &lt;SortableBlock blockId={block.id} onDelete={handleDeleteBlock}&gt;&#10;                                                            &lt;CanvasBlock block={block} /&gt;&#10;                                                        &lt;/SortableBlock&gt;&#10;                                                    &lt;/div&gt;&#10;                                                );&#10;                                            default:&#10;                                                return (&#10;                                                    &lt;div className=&quot;text-red-600&quot;&gt;&#10;                                                        Unknown block type: {block.type}&#10;                                                    &lt;/div&gt;&#10;                                                );&#10;                                        }&#10;                                    })()}&#10;&#10;                                    {/* Insertion divider after each block (including after last via i+1) */}&#10;                                    &lt;InsertionDivider onAdd={(type) =&gt; handleAddBlockAt(type, i + 1)} /&gt;&#10;                                &lt;/Fragment&gt;&#10;                            ))}&#10;                        &lt;/div&gt;&#10;                    &lt;/SortableContext&gt;&#10;&#10;                    &lt;DragOverlay&gt;&#10;                        {activeBlock?.type === &quot;text&quot; &amp;&amp; &lt;TextBlock block={activeBlock}/&gt;}&#10;                        {activeBlock?.type === &quot;canvas&quot; &amp;&amp; &lt;CanvasBlock block={activeBlock}/&gt;}&#10;                    &lt;/DragOverlay&gt;&#10;                &lt;/DndContext&gt;&#10;            &lt;/div&gt;&#10;        )&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>